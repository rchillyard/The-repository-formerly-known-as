package edu.neu.coe.huskySort.util;

import java.time.LocalDateTime;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * Class to implement an annotated benchmark.
 * In an annotated benchmark, the run method invokes the run method of the underlying benchmark, but takes the result and formats it appropriately, sending the resulting String to the annotator.
 * The run method itself returns void.
 *
 * @param <T> the underlying type of the Benchmark.
 */
public class AnnotatedBenchmark<T> {

    /**
     * Constructor.
     *
     * @param annotator      this is the Consumer&lt;String&gt; which accepts the preamble and the colophon Strings generated by the run method.
     * @param preambleFormat this is the format string which will, as part of the run method, generate a String to be sent to the annotator immediately before invoking run on the benchmark;
     *                       NOTE: this format string must include a %t (datetime format) directive to format the current date/time (see documentation on String.format).
     * @param benchmark      this is the Benchmark instance which will be used to implement the run method.
     * @param colophonFormat this is the format string which will, as part of the run method, generate a String to be sent to the annotator immediately after invoking run on the benchmark;
     *                       NOTE: this format string must include a %f (floating format) directive to format the result of renderer function (see documentation on String.format).
     * @param renderer       this is the function which will take the mean elapsed time (resulting from the run method of the benchmark) and render it as a double for presentation--typically this will normalize the time.
     */
    public AnnotatedBenchmark(Consumer<String> annotator, String preambleFormat, Benchmark<T> benchmark, String colophonFormat, Function<Double, Double> renderer) {
        this.benchmark = benchmark;
        this.annotator = annotator;
        this.preambleFormat = preambleFormat;
        this.colophonFormat = colophonFormat;
        this.renderer = renderer;
    }

    /**
     * Method to run the benchmark, given a specific T value.
     *
     * @param t the value of T
     * @param m the number of runs
     */
    public void run(T t, int m) {
        // CONSIDER whether this is actually inefficient
        run(() -> t, m);
    }

    /**
     * Method to run the benchmark, given a supplier of T values.
     *
     * @param supplier the supplier
     * @param m        the number of runs
     */
    public void run(Supplier<T> supplier, int m) {
        annotator.accept(String.format(preambleFormat, LocalDateTime.now()));
        final double time = benchmark.run(supplier, m);
        if (colophonFormat != null && renderer != null)
            annotator.accept(String.format(colophonFormat, renderer.apply(time)));
    }

    private final Consumer<String> annotator;
    private final String preambleFormat;
    private final String colophonFormat;
    private final Function<Double, Double> renderer;
    private final Benchmark<T> benchmark;

}
